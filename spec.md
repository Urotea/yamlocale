# i18n辞書管理仕様書(yamlocale)

JSON辞書の管理コスト削減のため、YAML形式での管理と変換フローを定義する。

## 1. 基本方針

- **入力フォーマット**: YAML
- **出力フォーマット**: JSON
  - **Flat**: ドット区切りのフラットなキー (e.g. `"button.add": "..."`)
  - **Nested**: ネストされたオブジェクト (e.g. `"button": { "add": "..." }`)
  - ※ オプションで選択可能（デフォルトは Nested）
- **ソースディレクトリ**: コマンドの引数で指定（**必須**）
- **出力ディレクトリ**: コマンドの引数で指定（**必須**）
- **対象言語**: コマンドの引数で指定 (e.g. `--languages ja,en`)
  - 指定がない場合は、YAMLファイル内から**自動検出**する（全ファイルで使用されている言語キーの和集合を対象とする）
- **監視モード**: `--watch` オプションにより、ファイルの変更を検知して自動再生成する

## 2. ディレクトリ構成とネームスペース戦略

出力されるJSONファイル名（ネームスペース）は、ソースディレクトリ内のファイル配置によって**自動的に決定**される。
ユーザーはディレクトリベースかファイルベースかを意識する必要はなく、混在が可能。

### ルール

1. **ルート直下のファイル**
   - ファイル名がネームスペースとなる。
   - **ソース**: `${ソースディレクトリ}/ky.yaml`
   - **出力**: `${出力ディレクトリ}/{locale}/ky.json`

2. **サブディレクトリ内のファイル**
   - ディレクトリ名がネームスペースとなる。
   - ディレクトリ内のファイル名はキーのプレフィックスとなる。
   - **ソース**: `${ソースディレクトリ}/common/button.yaml`
   - **出力**: `${出力ディレクトリ}/{locale}/common.json`

## 3. キー生成ルール

### キーのプレフィックス付与

- **ルート直下のファイル**: プレフィックスなし。
- **サブディレクトリ内のファイル**: ファイル名をプレフィックスとして付与する。

**例**:
- `ky.yaml` (ルート) 内の `title` キー => `title`
- `common/button.yaml` (サブディレクトリ) 内の `add` キー => `button.add`

### 出力フォーマットによる違い

生成されたキー構造（プレフィックス含む）に対して、出力フォーマットに応じて変換する。

- **Flat**: 全ての階層をドットで結合する。
  - `button.add` -> `"button.add": "..."`
- **Nested**: 階層構造をオブジェクトとして保持する。
  - `button.add` -> `"button": { "add": "..." }`

## 4. YAML記述ルール

- **言語併記**: 1ファイルに全言語（`ja`, `en`）を併記する。
- **完全性**: 最下層（Leaf）は必ず全言語のキーを持つこと。
- **ネスト**: 任意の深さのネストを許容する（推奨2-3階層）。

### 記述例

```yaml
# src/i18n/definitions/common/button.yaml
add:
  ja: 追加
  en: Add
delete:
  # 削除ボタンは赤色で表示
  ja: 削除
  en: Delete
```

## 5. バリデーション

変換時に以下のチェックを行う。

- **欠損チェック**: 全ての最下層キーに対して、**対象言語**で指定された全ての言語の翻訳が存在することを確認する。
- **重複チェック**: 同一ネームスペース内でキーが重複している場合はエラーとする。

## 6. 互換性

生成されるJSONは標準的な形式であるため、以下のライブラリ等と互換性がある。

- i18next (colocale)
- react-intl
- vue-i18n

**注記**: プレースホルダーの記法（`{{val}}` vs `{val}`）は、使用するライブラリに合わせてYAMLに記述する必要がある。
